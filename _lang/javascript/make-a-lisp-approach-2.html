<html> <head> </head> <body> <script type="text/javascript">

const l = console.log
const j = JSON.stringify

l(`hi`)


/*
 **********************************************************************
 *
 *  Here is attempt 2.
 *  
 *  An instance of LispA, is a Lisp list, or Symbolic Expression, but
 *  calling the class Sexp seems unnecessarily distracting.
 *  -   it is possible to treat ordinary Arrays as Lisp lists, but the
 *      present implementation is more parsimonious at the expense
 *      of execution speed (a hypothesis)
 *
 *  list.length == 0, or ':nil', signify (), the empty Lisp list.
 *
 *  Strings beginning with ':', are Lisp symbols.
 *  -   using JavaScript Symbols is too complicated
 *      (another hypothesis)
 *  -   TODO : it might be implemented that global.x is ':x' for
 *      syntactic sugar, but this doesn't work for ':+'
 */


let lispa_symbol_not_found = 'LispA symbol not found'

class LispA extends Array
{
    static symbol_not_found = lispa_symbol_not_found

    static is_key(candidate)
    {
        return ((typeof candidate == 'string') && (candidate[0] == ':'))
    }

    #env_parent = null

    #env_self = new Proxy({},{
        set(target, property, value, receiver)
        {
            if(LispA.is_key(property)) {
                target[property] = value
                return true
            }
            return false
        },
        get(target, property, receiver)
        {
            /* for convenience, no hiding of non-Lisp-symbols */

            if(property in target) return target[property]

            if(this.#env_parent) return this.#env_parent[property]

            throw LispA.symbol_not_found
        }
    })

    constructor(array)
    {
        super()

        /* TODO : replace with Proxy */
        array.forEach(e=>this.push(
            ((e instanceof Array) && ! (e instanceof LispA))
            ? new LispA(e) 
            : e
        ))
    }

    getEnv(key) { this.#env_self[key] }

    setEnv(key, val) { this.#env_self[key] = val }

    /**** BEGIN DEV ZONE ***********/

    #eval(lispa_val, lispa_env)
    {
        if(LispA.is_key(lispa_val)){

            if(lispa_val in lispa_env) return lispa_env[lispa_val] 

            throw [ LispA.symbol_not_found, lispa_val ]
        }  

        if((lispa_val instanceof LispA) && (lispa_val.length > 0)){ 

            /* keywords */
            switch(lispa_val[0]) {

/*  TODO:
 *  Consider the following framework :
 ******************************************
 *  CONTEXT : 
 *  Clojure :       'let' (behaves like CL's 'let*')
 *  Common Lisp :   'let' and                'let*'
 *  Scheme :        'let',                   'let*' and 'letrec'
 ******************************************
 *  -   :defg : var in global scope
 *
 *  -   :defl : var in local scope 
 *          ( 'outside'
 *              ( 'declared_here' 'usable_here' )
 *              ( 'unusable_here' ) )
 *
 *  -   :defp : var in parent scope
 *          ( 'grandparent'
 *              ( 'parent'
 *                  ( 'declared_here' 'usable_here' )
 *                  'usable_here' )
 *              ( 'unusable_here' ) )
 *
 *  -   :defpN : var in Nth-ancestral scope?
 *
 *  -   :defc : var in child scope : CLASSIC "let"
 *          ( 'declared_here' 
 *            'unusable_here'
 *            ( 'usable_here' )
 ******************************************
 *  -   :setl : redefine existing local variable
 ******************************************
 *  -   :defc : interpolated syntax : SHORTEST
 *          [':defc', [':a',1,':b',2,':c',3],[':+',':a',':b',':c']]
 *
 *  -   :defc# : block syntax
 *          [':defc%',[':a',':b',':c'],[1,2,3],[':+',':a',':b',':c']]
 *
 *  -   :defc@ : nested syntax 
 *          [':defc@',[':a',1,[':b',2,[':c',3]]],[':+',':a',':b',':c']]
 *
 *  -   :defc% : pair syntax : LONGEST
 *          [':defc%',[[':a',1],[':b',2],[':c',3]],[':+',':a',':b',':c']]
 *
 */




        /* let var : 
         * 
         *  [ ':local', ':x', 99 ]   becomes ...
         *  lispa_env[':x'] = 99
         */
                case ':local':
                    lispa_env[lispa_val[1]] = lispa_val[2] )
                    break;

        /* clojure : serial let : TODO : common lisp and others? 
         *
         *  [ ':let*', SERIAL_BINDINGS, EXECUTE_THIS ]
         *
         *      where, if SERIAL_BINDINGS is 
         *      [   [ ':x', 1 ], 
         *          [ ':y', [ ':+', ':x', 1 ] ], 
         *          [ ':z', [ ':*', ':y', 2 ] ] ]
         *
         *      and, if EXECUTE_THIS is
         *      [ list ':x', ':y', ':z' ]
         *
         */
                case ':let*':
                    
                    break;
                default:
            } 

            /* keyword :let */



            /* eval sub-lists */
            lispa_val.forEach( (lispa_subval, index)=> { 
                lispa_val[index] 
                    = this.#eval(lispa_subval, lispa_env) 
            } ) 

            /* function application */
            if(lispa_val[0] instanceof Function) {

                const [fn, ...args] = lispa_val
                return fn.apply(lispa_val, args)
            }

        }

        /* not LispA, or lispa_val.length==0 */
        return lispa_val

    }

    #read(a){ return a }

    rep(lispa_val){ this.#print( this.#eval (
        this.#read(this), this.#env_self ) ) }

    #print(a){ 
        console.log(JSON.stringify(a,null,2)) }

    /**** END DEV ZONE ***********/
}

const a = new LispA([ 111, 222, 333, "stringy", "stringstring",])
l(j(a))
a.rep()

const b = new LispA( [':+',[':*',3, 4], [':/',17 ,4]] )
b.setEnv(':+', (a, b)=>(a + b))
b.setEnv(':-', (a, b)=>(a - b))
b.setEnv(':*', (a, b)=>(a * b))
b.setEnv(':/', (a, b)=>(a / b))
l(j(b))
b.rep()






        </script>
    </body>
</html>
