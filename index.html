<html>

<script>
    "use strict"




    //  https://developer.mozilla.org/en-US/docs/Web/API/EventTarget
    //  [ class, extends, super, constructor ] keywords are only syntactic sugar (ES6) for prototype inheritence (see ES5)
    class Actor extends EventTarget {
    
        constructor (identity) {
            super ()
            this.beforeConstruction (identity)
            this.construction ()
            this.afterConstruction ()
        }    

        beforeConstruction (identity) {
            try {
                if ( (typeof identity !== 'string') || (identity.length == 0) ) {
                    throw "Please provide the instance of Actor with a .identity which is a string of length > 0"
                } 
            } catch (error) {
                console.log(`WARNING: ${error}`)
            }
        }

        construction () {
            this.inbox                      = []
            this.actorRegistryValidation    = this.validateActorRegistry()
            this.registerActor (this.actorRegistryValidation)
        }

        afterConstruction () {
            console.log (`NEWS: An instance of Actor has been constructed, identified as ${this.identity}.`)
        }

        validateActorRegistry () {
            return { 'actorRegistryIsArray' : 'actorRegistry' in window && Array.isArray(window.actorRegistry) }
        }


        registerActor (validation) {
            if ( validation.actorRegistryIsArray ) {
                window.actorRegistry.push ( this )
                console.log('NEWS: window.actorRegistry array found; pushed in an instance of Actor.')
            } else {
                window.actorRegistry    = [ this ] 
                console.log('NEWS: window.actorRegistry array not found; created it, containing an instance of Actor.')
            }
        }

        receiveMessage (message) {
            this.inbox.push (message)
            console.log (`NEWS: An actor ${this.identity} received a message: ${message}, which has been pushed into ${this.identity}\'s inbox.`)
        }

        sendMessage (message) {
            // TODO: call the recipient actor's receiveMessage(message) ?
        }


    }




    class Postman extends Actor {
   
        beforeConstruction () {
            super.beforeConstruction()

            //  super.__proto__.__proto__ is the anonymous prototoype of the Actor class,
            //      so any assignments to that, will be inherited by all actors.
            //  CONSIDER: aliasing this to a shorter variable.
            //
            //  Initialised data is deleted when the script cleans up. 
            //      This helps to reduce accidental contamination of objects via misused keys.
            super.__proto__.__proto__.init = {
                recipientKey :  Symbol(),
                subjectKey   :  Symbol(),
                contentKey   :  Symbol(),
            }
        }

        construction () {
            super.construction()
            this.requiredKeys       = [
                super.__proto__.__proto__.init.recipientKey, 
                super.__proto__.__proto__.init.subjectKey, 
                super.__proto__.__proto__.init.contentKey
            ]
            this.recipientRegistry  = { }
            this.messageDrawer      = { }
        }

        afterConstruction () {
            super.afterConstruction()
            console.log (`NEWS: ... the new actor identified as ${this.identity}, is also an instance of Postman.`)

            // TODO:  go to actorRegistry, register all registered Actors as recipients

            // TODO:  set Actor's Prototype afterConstruction() to : Find a postman, register self as a recipient.
        }
        
        validateActorRegistry () {
            try {

                var superValidity = super.validateActorRegistry().actorRegistryIsArray
                var selfValidity

                if (    superValidity 
                        && ! ( selfValidity = ! window.actorRegistry.some( actor => actor.constructor.name == 'Postman' ) )
                   ) {
                        throw( `An instance of Postman pre-exists in window.actorRegistry; no other shall be registered.` )
                }
                return { 
                    'actorRegistryIsArray'      : superValidity,    
                    'noPreRegisteredPostman'    : selfValidity
                }

                /*  This will return EITHER,

                        {   'actorRegistryIsArray'      : true,
                            'noPreRegisteredPostman'    : false }
  
                    OR,

                        {   'actorRegistryIsArray'      : false,
                            'noPreRegisteredPostman'    : undefined }  

                */

            } catch (error) {
                console.log(`WARNING: ${error}`)
                return { 
                    'actorRegistryIsArray'      : superValidity,    // true
                    'noPreRegisteredPostman'    : selfValidity      // true
                }
            }
        }

        registerActor (validation) {
            if ( validation.noPreRegisteredPostman ) {
                super.registerActor(validation)
            } else {
                console.log (`
                    NEWS: An instance of Postman, identified as ${this.identity},
                    may be constructed, but it will not be added to window.actorRegistry.
                `)  
            }
        }

        receiveMessage (message) {
            if ( this.validateMessage (message) ) {


                super.receiveMessage (message)

                console.log (`
                    As ${this.identity} is a postman, inboxed messages are to
                    be re-inboxed to the appropriate recipients, based on the 
                    postman\'s recipient registry. If a recipient\'s identity is
                    not in the registry, the message is moved from the postman\'s
                    inbox, to the postman\'s drawer with the addition of a new
                    key "recipient not in registry"`)
                

            }
        }
        
        validateMessage (message) {
            try {


                if ( typeof message !== 'object'  ) {
                    throw (`An instance of Postman received an invalid message: ${message} (an object is expected)`)
                }

                var keys = Object.getOwnPropertySymbols (message)
                if ( !this.requiredKeys.every (key => { return keys.includes(key) } ) ) {
                    throw (`An instance of Postman received an invalid message: ${message} (required keys were missing)`)
                }

                return true


            } catch (error) {
                console.log(`WARNING: ${error}`)
                return false
            }
        }

        registerRecipient (actor) {
            try {


                if ( ! actor instanceof Actor  ) {
                    throw (`An instance of Postman tried to register an invalid recipient: ${actor} (an instance of Actor is expected)`)
                }

                if ( actor.identity in this.recipientRegistry  ) {
                    throw (`An instance of Postman may not register a recipient whose identity is already in the Postman\'s registry: ${actor.identity}.`)
                }

                this.recipientRegistry[actor.identity] = actor
                console.log (`NEWS: An instance of Postman registered a new recipient: ${actor.identity}`)
                return true


            } catch (error) {
                console.log(`WARNING: ${error}`)
                return false
            }
        }



    }




//*   Some simple tests:


        console.log ('// BEGIN //\n// TESTS // Let\'s do some simple tests.\n// TESTS //')


        let nemo    = new Actor ()
        let joe1    = new Actor ('Joe')
        let joe2    = new Actor ('Joe')
        let jee     = new Actor ('Jee')
        let jae     = new Actor ('Jae')
        let pam     = new Postman ('Pam')
        let pat     = new Postman ('Pat')

        let m       =  {}
            m[pam.__proto__.__proto__.init.recipientKey]    = 1
            m[pam.__proto__.__proto__.init.subjectKey]      = 2
            m[pam.__proto__.__proto__.init.contentKey]      = 3
        console.log ('TEST: A variable, m, has been declared with valid message keys.')

        console.log ('TEST: ... we then attempt to inbox pam, the postman, with m:')
        pam.receiveMessage(m)

        // Test cleanup
        m = null 

        console.log ('TEST: ... after that, we then attempt to inbox Pam, the postman, with an empty object literal, {}:')
        pam.receiveMessage({})

        console.log ('TEST: Next, we attempt to register actor Joe_1 as a recipient in postman Pam\'s registry.')
        pam.registerRecipient(joe1)
        console.log ('TEST: ... then we attempt to register actor Joe_2 in the same.')
        pam.registerRecipient(joe2)
        console.log (`
            TEST: Whereas, window.actorRegistry is an array that can hold multiple 
            discrete instances of Actor which each have the same .identity: 
            ${window.actorRegistry.map( actor => actor.identity).join(', ') }`
        )

//*//




    // Script cleanup
    delete pam.__proto__.__proto__.init
    // TODO: this should occur in Postman's afterConstruction; there should be a dev-mode flag which copies out the keys for testing



//*     More testing:
        console.log ('TEST: After script cleanups deleted pam.__proto__.__proto__.init, pam.init now has the value of: ' + pam.init ) 
        console.log ('// TESTS //\n// TESTS // Let\'s do some simple tests.\n// END //')
//*//

// TODO: EventTarget.dispatchEvent() is supposed to run listeners synchronously. Test to see if asynchronous handoff can be achieved.

</script>

</html>
