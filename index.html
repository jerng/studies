<html>

<script>
    "use strict"


/* Possibly useful later.
const validation = window.actorRegistry.some( actor => actor instanceof Postman )

if ( ! validation ) {
window.actorRegistry.forEach ( actor => {
console.log(actor.identity)               
this.registerRecipient (actor) 
} )
}
*/

    //  https://developer.mozilla.org/en-US/docs/Web/API/EventTarget
    //  [ class, extends, super, constructor ] keywords are only syntactic 
    //  sugar  (ES6) for prototype inheritence (see ES5)
    class Actor extends EventTarget {
   
        // (new Actor).constructor
        constructor (identity) {
            super ()
            try {
                this.beforeConstruction (identity)
                this.construction ()
                this.afterConstruction ()
            } catch (error) {
                throw new Error (error) // Interrupt Actor construction.
            }
        }    

        // (new Actor).beforeConstruction
        beforeConstruction (identity) {
            if ( (typeof identity !== 'string') || (identity.length == 0) ) {
                throw new Error (`
                    (new Actor).constructor has been interrupted. Please provide 
                    the instance of Actor with a .identity which 
                    is a string of length > 0.`)
            } 
            this.identity                   = identity
            this.actorRegistryValidation    = this.validateActorRegistry()
            this.registerActor ( this.actorRegistryValidation )
        }

        // (new Actor).construction
        construction () {
            this.inbox                      = []
        }

        // (new Actor).afterConstruction
        afterConstruction () {
            console.log (`NEWS: 
                An instance of Actor has been constructed, identified as 
                ${this.identity}.`)
        }

        // (new Actor).validateActorRegistry
        validateActorRegistry () {
            return  {   'actorRegistryIsArray' : 

                            'actorRegistry' in window 
                            && 
                            Array.isArray(window.actorRegistry) 
                    }
        }

        // (new Actor).registerActor
        registerActor (validation) {
            if ( validation.actorRegistryIsArray ) {
                window.actorRegistry.push ( this )
                console.log(`NEWS: 
                    window.actorRegistry array found; pushed in an 
                    instance of Actor.`)
            } else {
                window.actorRegistry    = [ this ] 
                console.log(`NEWS:
                    window.actorRegistry array not found; created it, 
                    containing an instance of Actor.`)
            }
        }

        // (new Actor).receiveMessage
        receiveMessage (message) {
            this.inbox.push (message)
            console.log (`NEWS:
                An actor ${this.identity} received a message: ${message}, 
                which has been pushed into ${this.identity}\'s inbox.`)
        }

        // (new Actor).sendMessage
        sendMessage (message) {
            // TODO: call the recipient actor's receiveMessage(message) ?
        }

    }



    class Postman extends Actor {
  
        // (new Postman).constructor
        constructor (identity) {
            super(identity)
        }
 
        // (new Postman).beforeConstruction
        beforeConstruction (identity) {
            super.beforeConstruction(identity)

        }

        // (new Postman).construction
        construction () {
            super.construction()

            //  super.__proto__.__proto__ is the anonymous prototoype of the 
            //      Actor class,
            //      so any assignments to that, will be inherited by all actors.
            //  CONSIDER: aliasing this to a shorter variable.
            //  CONSIDER: switching this to use Symbol.for() and a global
            //              registry instead
            //
            //  Initialised data is deleted when the script cleans up. 
            //      This helps to reduce accidental contamination of objects i
            //      via misused keys.
            super.__proto__.__proto__.init = {
                recipientKey :  Symbol('rk'),
                subjectKey   :  Symbol('sk'),
                contentKey   :  Symbol('ck'),
            }

            this.requiredKeys       = [
                super.__proto__.__proto__.init.recipientKey, 
                super.__proto__.__proto__.init.subjectKey, 
                super.__proto__.__proto__.init.contentKey
            ]

            this.messageDrawer      = { }
            this.recipientRegistry  = { }

        }

        // (new Postman).afterConstruction
        afterConstruction () {
            super.afterConstruction()
            console.log (`NEWS: 
                ... the new actor identified as ${this.identity}, is also 
                an instance of Postman.`)



            // TODO:  set Actor's Prototype afterConstruction() to : Find a post
            //  man, register self as a recipient.
        }
        
        // (new Postman).validateActorRegistry
        validateActorRegistry () {
            try {

                var superValidity = super
                                    .validateActorRegistry()
                                    .actorRegistryIsArray
                var selfValidity

                if (    superValidity 
                        && 
                        ! ( selfValidity 
                            = ! 
                            window.actorRegistry.some ( 
                                actor => actor.constructor.name == 'Postman' 
                            ) 
                         )
                   ) {
                        throw new Error (`
                            An instance of Postman pre-exists in 
                            window.actorRegistry; no other shall be 
                            registered.` )
                }
                return { 
                    'actorRegistryIsArray'      : superValidity,    
                    'noPreRegisteredPostman'    : selfValidity
                }

                /*  This will return EITHER,

                        {   'actorRegistryIsArray'      : true,
                            'noPreRegisteredPostman'    : false }
  
                    OR,

                        {   'actorRegistryIsArray'      : false,
                            'noPreRegisteredPostman'    : undefined }  

                */

            } catch (error) {
                console.log(error)
                return { 
                    'actorRegistryIsArray'      : superValidity,    // true
                    'noPreRegisteredPostman'    : selfValidity      // true
                }
            }
        }

        // (new Postman).registerActor
        registerActor (validation) {
            if ( validation.noPreRegisteredPostman ) {
                super.registerActor(validation)
            } else {

                // TODO: consider changing this to a proper OOP-style singleton

                throw new Error (`
                    (new Postman).constructor has been interrupted. An instance 
                    of Postman, identified as 
                    ${this.identity}, may not be constructed.`)
            }
        }

        // (new Postman).registerRecipient
        registerRecipient (actor) {
            try {


                if ( ! actor instanceof Actor  ) {
                    throw new Error (`
                        An instance of Postman tried to register an invalid 
                        recipient: ${actor} (an instance of Actor is expected)`)
                }

                if ( actor.identity in this.recipientRegistry  ) {
                    throw new Error (`An instance of Postman may not register a recipient 
                    whose identity is already in the Postman's registry: 
                    ${actor.identity}.`)
                }

                this.recipientRegistry[actor.identity] = actor
                console.log (`NEWS: 
                    An instance of Postman registered a new recipient: 
                    ${actor.identity}`)
                return true


            } catch (error) {
                console.error(error)
                return false
            }
        }

        // (new Postman).receiveMessage
        receiveMessage (message) {
            if ( this.validateMessage (message) ) {


                super.receiveMessage (message)

                console.log (`
                    As ${this.identity} is a postman, inboxed messages are to
                    be re-inboxed to the appropriate recipients, based on the 
                    postman's recipient registry. If a recipient\'s identity is
                    not in the registry, the message is moved from the postman's
                    inbox, to the postman's drawer with the addition of a new
                    key "recipient not in registry"`)
                

            }
        }
        
        // (new Postman).validateMessage
        validateMessage (message) {
            try {

                if ( typeof message !== 'object'  ) {
                    throw new Error (`
                        An instance of Postman received an invalid message: 
                        ${message} (an object is expected)`)
                }

                var keys = Object.getOwnPropertySymbols (message)

                var allRequiredKeysFound =  this.requiredKeys.every ( 
                                                key => keys.includes(key) 
                                            )

                if  ( ! allRequiredKeysFound ) 
                {
                    throw new Error (`
                        An instance of Postman received an invalid message: 
                        ${message} (required keys were missing)`)
                }

                return true


            } catch (error) {
                console.error(error)
                return false
            }
        }




    }




//*   Some simple pre-tests:


        console.log ('// BEGIN //\n// TESTS // Let\'s do some simple pre-tests.\n// TESTS //')


try             { let nemo    = new Actor () } 
catch (error)   { console.error(error) }
        
        let joe1    = new Actor ('Joe')
        let joe2    = new Actor ('Joe')
        let jee     = new Actor ('Jee')
        let jae     = new Actor ('Jae')
        let pam     = new Postman ('Pam')

try             { let pat     = new Postman ('Pat') }
catch (error)   { console.error(error) }

        let m       =  {}
            m[pam.__proto__.__proto__.init.recipientKey]    = 1
            m[pam.__proto__.__proto__.init.subjectKey]      = 2
            m[pam.__proto__.__proto__.init.contentKey]      = 3
        console.log ('TEST: A variable, m, has been declared with valid message keys.')

        console.log ('TEST: ... we then attempt to inbox pam, the postman, with m:')

        pam.receiveMessage(m)

        // Test cleanup
        // m = null 

        console.log ('TEST: ... after that, we then attempt to inbox Pam, the postman, with an empty object literal, {}:')
        pam.receiveMessage({})

        console.log ('TEST: Next, we attempt to register actor Joe_1 as a recipient in postman Pam\'s registry.')
        pam.registerRecipient(joe1)
        console.log ('TEST: ... then we attempt to register actor Joe_2 in the same.')
        pam.registerRecipient(joe2)
        console.log (`
            TEST: Whereas, window.actorRegistry is an array that can hold multiple 
            discrete instances of Actor which each have the same .identity: 
            ${window.actorRegistry.map( actor => actor.identity).join(', ') }`
        )

        console.log(`TEST: window.actorRegistry identities: ${window.actorRegistry.map(x => x.identity)}`)
        console.log(`TEST: pam.recipientRegistry identities: ${Object.keys(pam.recipientRegistry)}`)


//*//




    // Script cleanup
    delete pam.__proto__.__proto__.init
    // TODO: this should occur in Postman's afterConstruction; there should be a dev-mode flag which copies out the keys for testing



//*     More testing:
        console.log ('TEST: After script cleanups deleted pam.__proto__.__proto__.init, pam.init now has the value of: ' + pam.init ) 
        console.log ('// TESTS //\n// TESTS // Let\'s do some simple tests.\n// END //')
//*//

// TODO: EventTarget.dispatchEvent() is supposed to run listeners synchronously. Test to see if asynchronous handoff can be achieved.

</script>

</html>
